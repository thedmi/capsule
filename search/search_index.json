{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Capsule is a .NET library and C# source generator that provides thread-safe object encapsulation in an automatic and boilerplate-free way. It can be used as run-to-completion runtime for state machines, as actor library or just to avoid manual locking and synchronization code.</p> <p>Capsule turns ordinary objects into thread-safe capsules. A capsule can be used concurrently without the risk of race conditions. The original interface is retained, so this is transparent for callers.</p> <p></p> <p>To create a capsule, you provide an implementation (green) and specify how the methods and properties (yellow) are to be encapsulated. Capsule then adds synchronization infrastructure (blue) and the hull (red), a generated interface adapter.</p> <p>Apart from a few attributes and the requirement to make methods <code>async</code>, implementations remain free of synchronization code. This keeps code readable and focused. It also improves testability because synchronization concerns are separated.</p>"},{"location":"10_quickstart/","title":"Quick Start","text":"<p>First, install the  and  Nuget packages.</p> <p>Now define a capsule implementation that you want to wrap in a thread-safe way:</p> <pre><code>[Capsule]\npublic class MemoryCache\n{\n    private readonly Dictionary&lt;int, Entry&gt; _cacheEntries = new();\n\n    [Expose]\n    public async Task InsertOrUpdateAsync(int key, string content)\n    {\n        _cacheEntries[key] = new Entry(DateTime.UtcNow, content);\n    }\n\n    [Expose]\n    public async Task&lt;string?&gt; GetAsync(int key)\n    {\n        return _cacheEntries.GetValueOrDefault(key)?.Content;\n    }\n\n    private record Entry(DateTime Timestamp, string Content);\n}\n</code></pre> <p>This is a simple example of an in-memory cache. It is so simple that it could have been implemented with ordinary locks or a concurrent dictionary. We'll do it with Capsule anyway for the sake of this example.</p> <p>The dictionary in <code>MemoryCache</code> is mutable state that must not be accessed concurrently. Capsule turns <code>MemoryCache</code> into a capsule by finding the <code>[Capsule]</code> attribute and wrapping the class in a thread-safe hull with an interface that matches the <code>[Expose]</code> attributed methods. This can then be used in concurrent contexts, e.g. in an ASP.NET Core controller:</p> <pre><code>[Controller]\npublic class SampleController(IMemoryCache cache)\n{\n    [HttpGet]\n    public async Task&lt;string?&gt; GetAsync(int key) =&gt; await cache.GetAsync(key);\n\n    [HttpPut]\n    public async Task InsertOrUpdateAsync(int key, string content) =&gt; \n        await cache.InsertOrUpdateAsync(key, content);\n}\n</code></pre> <p>Note the usage of <code>IMemoryCache</code> (capsule interface) instead of <code>MemoryCache</code>. The former is backed by the thread-safe hull, the latter is the non-thread-safe implementation.</p> <p>As you can see, the only thing we need to make the implementation thread-safe are the <code>[Capsule]</code> and <code>[Expose]</code> attributes. Neither locks nor concurrent collections (that are hard to use correctly) are needed.</p> <p>Typically, you'll register the capsule in DI. Capsule comes with support for Microsoft dependency injection, which is included in the <code>Capsule.Core</code> nuget package:</p> <pre><code>services.AddCapsuleHost();\n\nservices.AddSingleton&lt;IMemoryCache&gt;(\n    p =&gt; new MemoryCache(TimeSpan.FromDays(1))\n        .Encapsulate(p.GetRequiredService&lt;CapsuleRuntimeContext&gt;()));\n</code></pre> <p>The first line registers Capsule infrastructure. The second line instantiates <code>MemoryCache</code> and wraps it in the thread-safe hull using <code>Encapsulate()</code>. The result is then registered as <code>IMemoryCache</code>.</p>"},{"location":"20_motivation/","title":"Motivation","text":"<p>Writing thread-safe code is hard. .NET offers a lot of powerful synchronization primitives and helper classes, but using them in complex problem domains often leads to a lot of boilerplate, lower readability, reduced testability and consequently a higher risk for bugs.</p> <p>Capsule aims to improve the situation through the following approaches:</p> <ul> <li>Provide generic thread-safe synchronization that allows for different synchronization modes such as \"await result\" or \"fire and forget\"</li> <li>Ensure usage of thread-safe objects follows an object-oriented approach that integrates seamlessly with ordinary code</li> <li>Generate boilerplate instead of making library users maintain it themselves</li> </ul> <p>To achieve this, Capsule employs well-known synchronization primitives such as <code>Channel&lt;T&gt;</code> and <code>TaskCompletionSource</code> and a purpose-built source generator.</p>"},{"location":"30_usage/","title":"Usage","text":""},{"location":"30_usage/#installation","title":"Installation","text":"<p>Capsule is shipped as a set of Nuget packages:</p> <ul> <li> Core functionality such as invocation loop and synchronizer implementations. Also contains dependency injection registration extensions.</li> <li> C# source generator that generates interfaces and encapsulation boilerplate based on attributes.</li> <li> Test support library.</li> </ul> <p>To get started, install the <code>Capsule.Core</code> and <code>Capsule.Generator</code> packages. Then, register the necessary dependencies with the <code>AddCapsuleHost()</code> DI extension method.</p>"},{"location":"30_usage/#implementing-capsules","title":"Implementing Capsules","text":"<p>The capsule implementation is the class that needs to be made thread-safe. You create it, but do not add any synchronization primitives yourself.</p> <p>By adding he <code>[Capsule]</code> attribute to that class, the Capsule generator is instructed to add the following parts:</p> <ul> <li>The capsule interface is generated or referenced.</li> <li>A static extension class is generated, containing the hull and an <code>Encapsulate()</code> extension method. This is what turns your capsule implementation into a thread-safe object.</li> </ul> <p>The following subsections provide further details on these two parts.</p>"},{"location":"30_usage/#interface-generation","title":"Interface Generation","text":"<p>Capsule generator is able to generate a capsule interface for each capsule implementation.</p> <p>By default, Capsule considers the list of implemented interfaces on the Capsule implementation:</p> <ul> <li>If there is exactly one interface that is not <code>[CapsuleIgnore]</code> attributed, that interface is used and no additional interface is generated.</li> <li>Otherwise, an interface with the same name as the implementation, but prefixed with an \"I\", will be generated.</li> </ul> <p>Interface generation can be customized through <code>CapsuleAttribute.InterfaceGeneration</code>:</p> <ul> <li><code>Enable</code>: Generate an interface.</li> <li><code>Disable</code>: Do not generate an interface.</li> <li><code>Auto</code>: The default behavior described above applies.</li> </ul> <p>The interface name can be customized through <code>CapsuleAttribute.InterfaceName</code>:</p> <ul> <li>If this property is specified and non-null, that interface name will be used.</li> <li>Otherwise, the default behavior applies.</li> </ul> <p>Note</p> <p>If you bring your own interface, you'll need to ensure it matches the exposed methods and properties. Otherwise, the build will fail.</p>"},{"location":"30_usage/#exposing-methods-properties","title":"Exposing Methods &amp; Properties","text":"<p>In addition to the <code>[Capule]</code> attribute on the implementation class, you'll need to add the <code>[Expose]</code> attribute to all methods and properties that you want to make accessible through the capsule interface. The following restrictions apply:</p> <ul> <li>The exposed methods must have a return type that is compatible with the chosen synchronization mode (see below).</li> <li>Properties are restricted to immutable getters and <code>PassThrough</code> synchronization mode must be used.</li> </ul> <p>The synchronization mode defaults to <code>AwaitCompletion</code>. Different modes can be specified through the <code>ExposeAttribute.Synchronization</code> property.</p>"},{"location":"30_usage/#synchronization","title":"Synchronization","text":"<p>Capsule can expose methods in different ways to match different use cases. The synchronization mode controls if/how invocations are awaited and whether thread-safety is guaranteed. Capsule defaults to \"await completion\" synchronization. This is the only mode that is thread-safe and makes encapsulated objects behave in an object-oriented way from the caller's perspective.</p>"},{"location":"30_usage/#synchronization-modes","title":"Synchronization Modes","text":"<p>The following synchronization modes are supported:</p> Synchronization Mode Completes when Sync / Async Behavior <code>AwaitCompletion</code> (default) implementation completes async <code>AwaitEnqueueing</code> invocation has been enqueued sync or async (details see below) <code>AwaitReception</code> invocation has been dequeued async <code>PassThrough</code> implementation completes sync or async <code>AwaitCompletionOrPassThroughIfQueueClosed</code> implementation completes async"},{"location":"30_usage/#invocation-owner","title":"Invocation Owner","text":"<p>Invocations are either caller-owned  or loop-owned . Caller-owned invocations behave the same way as you'd expect any invocation on an object would behave: Results and exceptions are passed back to the caller.</p> <p>Loop-owned invocations enable a \"fire and forget\" communication between objects. The caller can continue before the invocation has been executed, but as a result won't receive return values or exceptions. <code>AwaitEnqueueing</code> is the recommended synchronization mode for \"fire and forget\" style communication.</p>"},{"location":"30_usage/#sync-async","title":"Sync / Async","text":"<p>Caller-owned invocations must be async. This is due to the fact that the caller will need to be suspended until the invocation can be dequeued/executed.</p> <p>A special case regarding sync/async is <code>AwaitEnqueueing</code> synchronization mode. This mode only needs to enqueue the invocation, which is a synchronous operation. Thus, such methods will be exposed as synchronous on the interface, unless the interface was resolved from the list of implemented interfaces on the Capsule (see interface generation for details).</p>"},{"location":"30_usage/#thread-safety","title":"Thread-Safety","text":"<p><code>AwaitCompletion</code>, <code>AwaitEnqueueing</code> and <code>AwaitReception</code> modes provide thread safety , <code>PassThrough</code> does not .</p> <p><code>PassThrough</code> is not thread-safe because it doesn't enqueue the invocation, but executes it directly. It is only safe for immutable operations and is typically used with get-only properties that return an immutable field of the capsule implementation (e.g. an ID).</p> <p><code>AwaitCompletionOrPassThroughIfQueueClosed</code> is a special case synchronization mode that behaves as <code>AwaitCompletion</code>, but falls back to <code>PassThrough</code> if the invocation queue has been closed. This is useful for <code>DisposeAsync()</code> operations, where <code>DisposeAsync()</code> may be called by DI infrastructure just before shutdown. At that point, the invocation queue has already been terminated and <code>AwaitCompletion</code> would throw a <code>CapsuleInvocationException</code>. When it falls back to <code>PassThrough</code>, thread-safety is not guaranteed.</p>"},{"location":"30_usage/#run-to-completion-semantics","title":"Run to Completion Semantics","text":"<p>All synchronization modes except <code>PassThrough</code> will execute one invocation at a time (aka run-to-completion scheduling). Make sure that your implementation completes quickly, as a blocked or delayed implementation will delay all pending invocations. This means that it is generally not a good idea to use <code>Task.Delay()</code> in capsule implementations (use a timer instead).</p>"},{"location":"30_usage/#exception-handling","title":"Exception Handling","text":"<p>Exceptions that throw out of capsule implementations are routed the same way as return values are, so caller-owned invocations will throw exceptions back to the caller.</p> <p>Loop-owned synchronization modes throw exceptions back into the invocation loop, because there is no caller that waits for the invocation to complete. In a default Capsule setup, such exceptions will abort the invocation loop and consequently the hosted service that runs it. This in turn will terminate the application.</p> <p>This behavior is consistent with how .NET background services treat uncaught exceptions in .NET 6 and newer. The rationale for this is that uncaught exceptions must not go unnoticed. Consequently, you'll need to ensure that expected exceptions are caught and handled in capsule implementations.</p> <p>Optionally, the failure mode can be changed to <code>Continue</code> through <code>CapsuleOptions.FailureMode</code>. With this failure mode, uncaught loop-owned exceptions will be logged and then ignored.</p>"},{"location":"30_usage/#cancellation","title":"Cancellation","text":"<p>Capsule treats cancellation tokens on exposed methods as any other parameter, so the tokens flow through to the capsule implementation unmodified and cancellation can be realized in the capsule implementation.</p> <p>In case the cancellation leads to an <code>OperationCanceledException</code> being thrown out of the capsule implementation, the same behavior as outlined in excpetion handling applies, so you'll probably want to catch these exceptions.</p> <p>In any case, cancellation does not remove the invocation from the queue or otherwise change synchronization behavior.</p>"},{"location":"30_usage/#disposable-capsules","title":"Disposable Capsules","text":"<p>In case your capsule implementation manages disposable resources, you may need to make the capsule disposable, too. Depending on your usage patterns, there are two possibilities to achieve this:</p> <p>The recommended approach is to implement <code>IAsyncDisposable</code>. Like this, you'll be able to treat the dispose operation the same way as other methods. The <code>DisposeAsync()</code> method can be exposed with <code>[Expose]</code>, invocations will then flow through the invocation queue as expected. In case the capsules are registered with DI, you may want to use <code>AwaitCompletionOrPassThroughIfQueueClosed</code> synchronization mode to avoid exceptions on app shutdown (see synchronization modes for details).</p> <p>Another possibility is to implement <code>IDisposable</code> and expose the <code>Dispose()</code> method with synchronization mode <code>PassThrough</code>. With this approach, <code>Dispose()</code> will be called synchronously, thread-safety is not guaranteed. However, for cases where <code>Dispose()</code> is only called by DI on app shutdown, this may be a suitable solution for you, because Capsule hosting will have terminated and processed all invocation queues by the time DI calls <code>Dispose()</code>.</p>"},{"location":"30_usage/#opt-in-features","title":"Opt-In Features","text":""},{"location":"30_usage/#async-initializer","title":"Async Initializer","text":"<p>Capsule implementations that need to perform asynchronous initialization can implement the <code>CapsuleFeature.IInitializer</code> interface, which defines a <code>Task InitializeAsync()</code> method.</p> <p>Capsule will enqueue a single call to this method when a capsule is instantiated through <code>Encapsulate()</code>, so the invocation is guaranteed to be the first one to end up in the invocation queue and will run as soon as the invocation loop is started.</p>"},{"location":"30_usage/#timers","title":"Timers","text":"<p>Run-to-completion semantics dictate that individual runs should complete quickly. In other words, awaiting large delays or even sleeping is discouraged and will break responsiveness of the capsule, potentially leading to invocation queue exhaustion.</p> <p>To work around this limitation, Capsule provides a timer service. The service can be used by making capsules implement <code>CapsuleFeature.ITimers</code>. When implemented, Capsule will inject an <code>ITimerService</code> during encapsulation.</p> <p>Note</p> <p>The timer service will not be available when the constructor of the capsule implementation runs as this would create a chicken-and-egg problem. If you need to start timers when the capsule is instantiated, use an async initializer.</p> <p>You can then use the timer service to register callbacks with a timeout through <code>StartSingleShot()</code>. When the timeout expires, the callback will be enqueued as just another invocation. Timers thus adheres to the thread-safety guarantees of the capsule.</p> <p>Pending timers can also be cancelled. Either cancel a single timer through its <code>TimerReference</code>, or cancel all timers through <code>ITimerService.CancelAll()</code>.</p> <p>For cases where only a single timer is needed, but that timer may be restarted multiple times, consider passing a <code>discriminator</code> to <code>StartSingleShot()</code>. The timer service will then ensure that at most one timer with the same discriminator exists, previous ones will be cancelled.</p>"},{"location":"30_usage/#testing","title":"Testing","text":"<p>One of the advantages of Capsule is that implementations remain free of synchronization code like locks or similar. Consequently, implementations can simply be unit tested by omitting the encapsulation in tests.</p> <p>Generally, the following approaches work best:</p> <ul> <li>Use the unencapsulated implementation in unit tests.</li> <li>Use the whole Capsule in integration tests (integration as in \"tests the combination of several classes together\").</li> </ul>"},{"location":"30_usage/#test-support-library","title":"Test Support Library","text":"<p>A test support library called  is available. It provides fake implementations of Capsule infrastructure that simplifies certain test scenarios:</p> <ul> <li><code>FakeTimerService</code>: An <code>ITimerService</code> that can be injected into capsules that use Timers. Timer firing can be controlled from test code to avoid delays in tests.</li> <li><code>FakeSynchronizer</code>: An <code>ICapsuleSynchronizer</code> that just executes invocations directly.</li> </ul>"},{"location":"40_how_does_this_work/","title":"How does this Work?","text":"<p>Internally, Capsule implements a message queue and run-to-completion semantics. This means that invocations are not executed directly but enqueued in a thread-safe channel and then processed one at a time (also known as turn-based concurrency).</p> <p>When a capsule is instantiated, the following infrastructure is created:</p> <ul> <li>a dedicated, thread-safe channel</li> <li>a hull that implements the capsule interface and passes invocations to its synchronizer, which in turn passes them to the channel</li> <li>an invocation loop that executes invocations read from the channel</li> </ul> <p>To ensure the invocation loops remain active, they are registered with a capsule host. This is a service that runs and monitors the invocation loops. When using <code>AddCapsuleHost()</code> to register dependencies, the capsule host is started and stopped from <code>CapsuleBackgroundService</code>, an <code>IHostedService</code> implementation.</p>"},{"location":"50_comparison_with_other_concepts/","title":"Comparison with Other Concepts","text":""},{"location":"50_comparison_with_other_concepts/#actor-model","title":"Actor Model","text":"<p>Capsule can be considered an opinionated actor model implementation. It fulfils the concurrency guarantees made by the actor model and supports all operations that actors must support.</p> <p>However, because different people have different understandings of how an actor implementation in .NET should look like, Capsule avoids the term \"actor\" and calls them \"capsules\" instead.</p>"},{"location":"50_comparison_with_other_concepts/#capsule-vs-orleans-dapr-actors","title":"Capsule vs. Orleans / Dapr Actors","text":"<p>Orleans and Dapr Actor use a pattern they call \"virtual actors\". With this approach, the actor client does not care about actor activation and life-cycle. Also, actor location is transparent, so an actor may be running locally or remotely. The virtual actor pattern is well suited for distributed applications where scalability is a major concern.</p> <p>Capsules, on the other hand, are explicitly created and destroyed, and they always live in the same process as the caller. This makes it a good choice for local thread-safety problems where life-cycle is relevant, e.g. device controllers or file / process management.</p>"},{"location":"50_comparison_with_other_concepts/#capsule-vs-akkanet-protoactor","title":"Capsule vs. Akka.NET / Proto.Actor","text":"<p>In contrast to \"pure\" actor implementations such as Akka.NET or Proto.Actor, Capsule supports ordinary object-oriented interfaces and doesn't force every interaction to go through <code>Tell()</code> or <code>Ask()</code> methods. So invoking a method on a Capsule vs on an ordinary object is indistinguishable from the caller's perspective.</p> <p>Also, Capsule is meant to solve individual multi-threading problems where necessary, leaving the rest of the application unaffected. This is different from the \"everything is an actor\" approach that Akka.NET and Proto.Actor take.</p> <p>So if you're looking for an all-in actor framework with lots of features geared towards that approach, use Akka.NET or Proto.Actor. If, on the other hand, you want to use actors only in a part of the application and have actor interfaces that feel object-oriented, Capsule is for you.</p>"},{"location":"50_comparison_with_other_concepts/#state-machines","title":"State Machines","text":"<p>Capsule is not a state machine library, but it provides the runtime environment that works well with state machines. In fact, when using UML state machine formalisms or similar approaches, a run-to-completion execution model is assumed. Capsule is exactly that.</p> <p>Consequently, Capsule can be combined with any form of state machine implementation (e.g. switch/case or state pattern) to get thread-safe, reactive state machines.</p>"}]}