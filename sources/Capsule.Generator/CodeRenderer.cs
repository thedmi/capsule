using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Capsule.Generator;

internal class CodeRenderer
{
    private readonly SourceProductionContext _context;

    private readonly CapsuleDefinition _definition;

    private readonly INamedTypeSymbol _classSymbol;

    private readonly ImmutableArray<ExposeDefinition> _exposedMethods;

    public CodeRenderer(
        SourceProductionContext context,
        CapsuleDefinition definition,
        INamedTypeSymbol classSymbol,
        ImmutableArray<ExposeDefinition> exposedMethods)
    {
        _context = context;
        _definition = definition;
        _classSymbol = classSymbol;
        _exposedMethods = exposedMethods;
    }

    public void RenderCapsuleInterface()
    {
        if (!_definition.GenerateInterface)
        {
            return;
        }
        
        var namespaceName = _classSymbol.ContainingNamespace.ToDisplayString();

        var methods = _exposedMethods.Select(d => RenderHullMethodOrProperty(d, false));
        
        var code =
            $$"""
              // <auto-generated/>
              #nullable enable

              namespace {{namespaceName}};

              public interface {{_definition.InterfaceName}}
              {
              {{string.Join("\n\n", methods)}}
              }
              """;
        
        _context.AddSource($"{_definition.InterfaceName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    public void RenderExtensions()
    {
        var namespaceName = _classSymbol.ContainingNamespace.ToDisplayString();

        var extensionsClassName = _classSymbol.Name + "CapsuleExtensions";
        
        var methods = _exposedMethods
            .Select(d => RenderHullMethodOrProperty(d, true));
        
        var code =
            $$"""
              // <auto-generated/>
              #nullable enable
              
              using Capsule;
              
              namespace {{namespaceName}};

              public static class {{extensionsClassName}}
              {
                  public static {{_definition.InterfaceName}} Encapsulate(this {{_classSymbol.Name}} impl, CapsuleRuntimeContext context) =>
                      new Hull(impl, context.SynchronizerFactory.Create(impl, context));
              
                  public class Hull : {{_definition.InterfaceName}} 
                  {
                      private readonly {{_classSymbol.Name}} _impl;
                      
                      private readonly ICapsuleSynchronizer _synchronizer;
                      
                      public Hull({{_classSymbol.Name}} impl, ICapsuleSynchronizer synchronizer)
                      {
                          _impl = impl;
                          _synchronizer = synchronizer;
                      }
                      
                  {{string.Join("\n\n    ", methods)}}
                  
                      // Ensure the synchronizer is closed when the hull is finalized to avoid memory leaks on the
                      // queue reader side (invocation loop).
                      ~Hull() => _synchronizer.Close();
                  }
              }
              """;

        // Add the source code to the compilation.
        _context.AddSource($"{extensionsClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
    
    private static string RenderHullMethodOrProperty(ExposeDefinition exposeDefinition, bool renderImplementation)
    {
        return exposeDefinition.Symbol switch
        {
            IMethodSymbol m => RenderHullMethod(m, exposeDefinition.Synchronization, renderImplementation),
            IPropertySymbol p => RenderHullProperty(p, exposeDefinition.Synchronization, renderImplementation),
            _ => throw new ArgumentOutOfRangeException(nameof(exposeDefinition.Symbol))
        };
    }

    private static string RenderHullMethod(
        IMethodSymbol method,
        Synchronization proxyMethod,
        bool renderImplementation)
    {
        var parameterDeclarations = string.Join(
            ", ",
            method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));

        var arguments = string.Join(", ", method.Parameters.Select(p => $"{p.Name}"));

        var signature = $"    public {method.ReturnType} {method.Name}({parameterDeclarations})";

        var synchronizerCall = IsValueTask(method.ReturnType)
            ? $"new {method.ReturnType}(_synchronizer.{proxyMethod}(() => _impl.{method.Name}({arguments}).AsTask()))"
            : $"_synchronizer.{proxyMethod}(() => _impl.{method.Name}({arguments}))";
        
        var body = renderImplementation ? $" =>\n            {synchronizerCall};" : ";";

        return $"{signature}{body}";
    }
    
    private static string RenderHullProperty(
        IPropertySymbol property,
        Synchronization synchronization,
        bool renderImplementation)
    {
        return $$"""
                     public {{property.GetMethod!.ReturnType}} {{property.Name}}
                 """ +
               (renderImplementation
                   ? $$"""
                        =>
                                   _synchronizer.{{synchronization}}(() => _impl.{{property.Name}});
                       """
                   : " { get; }");
    }

    private static bool IsValueTask(ITypeSymbol typeSymbol) =>
        typeSymbol.Name == "ValueTask" && typeSymbol.ContainingNamespace.ToDisplayString() == "System.Threading.Tasks";
}
