using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Capsule.Generator;

internal class CodeRenderer(
    SourceProductionContext context,
    CapsuleDefinition definition,
    INamedTypeSymbol classSymbol,
    ImmutableArray<ExposeDefinition> exposedMethods)
{
    public void RenderCapsuleInterface()
    {
        if (!definition.GenerateInterface)
        {
            return;
        }
        
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var methods = exposedMethods.Select(d => RenderHullMethodOrProperty(d, false));
        
        var code =
            $$"""
              // <auto-generated/>
              #nullable enable

              namespace {{namespaceName}};

              public interface {{definition.InterfaceName}}
              {
              {{string.Join("\n\n", methods)}}
              }
              """;
        
        context.AddSource($"{definition.InterfaceName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    public void RenderExtensions()
    {
        var implClassName = NestedTypeFqn(classSymbol);
        
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var extensionsClassName = implClassName.Replace(".", "") + "CapsuleExtensions";
        
        var methods = exposedMethods
            .Select(d => RenderHullMethodOrProperty(d, true));
        
        var code =
            $$"""
              // <auto-generated/>
              #nullable enable
              
              using Capsule;
              
              namespace {{namespaceName}};

              public static class {{extensionsClassName}}
              {
                  public static {{definition.InterfaceName}} Encapsulate(this {{implClassName}} impl, CapsuleRuntimeContext context) =>
                      new Hull(impl, context.SynchronizerFactory.Create(impl, context.Host));
              
                  public class Hull : {{definition.InterfaceName}} 
                  {
                      private readonly {{implClassName}} _impl;
                      
                      private readonly ICapsuleSynchronizer _synchronizer;
                      
                      public Hull({{implClassName}} impl, ICapsuleSynchronizer synchronizer)
                      {
                          _impl = impl;
                          _synchronizer = synchronizer;
                      }
                      
                  {{string.Join("\n\n    ", methods)}}
                  }
              }
              """;

        // Add the source code to the compilation.
        context.AddSource($"{extensionsClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
    
    private static string RenderHullMethodOrProperty(ExposeDefinition exposeDefinition, bool renderImplementation)
    {
        return exposeDefinition.Symbol switch
        {
            IMethodSymbol m => RenderHullMethod(m, exposeDefinition.Synchronization, exposeDefinition.PassThroughIfQueueClosed, renderImplementation),
            IPropertySymbol p => RenderHullProperty(p, exposeDefinition.Synchronization, renderImplementation),
            _ => throw new ArgumentOutOfRangeException(nameof(exposeDefinition.Symbol))
        };
    }

    private static string RenderHullMethod(
        IMethodSymbol method,
        Synchronization proxyMethod,
        bool passThroughIfQueueClosed,
        bool renderImplementation)
    {
        var parameterDeclarations = string.Join(
            ", ",
            method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));

        var arguments = string.Join(", ", method.Parameters.Select(p => $"{p.Name}"));

        var signature = $"    public {method.ReturnType} {method.Name}({parameterDeclarations})";

        var passThrough = passThroughIfQueueClosed ? ", true" : "";

        var synchronizerCall = IsValueTask(method.ReturnType)
            ? $"new {method.ReturnType}(_synchronizer.{proxyMethod}(() => _impl.{method.Name}({arguments}).AsTask(){passThrough}))"
            : $"_synchronizer.{proxyMethod}(() => _impl.{method.Name}({arguments}){passThrough})";
        
        var body = renderImplementation ? $" =>\n            {synchronizerCall};" : ";";

        return $"{signature}{body}";
    }
    
    private static string RenderHullProperty(
        IPropertySymbol property,
        Synchronization synchronization,
        bool renderImplementation)
    {
        return $$"""
                     public {{property.GetMethod!.ReturnType}} {{property.Name}}
                 """ +
               (renderImplementation
                   ? $$"""
                        =>
                                   _synchronizer.{{synchronization}}(() => _impl.{{property.Name}});
                       """
                   : " { get; }");
    }

    private static bool IsValueTask(ITypeSymbol typeSymbol) =>
        typeSymbol.Name == "ValueTask" && typeSymbol.ContainingNamespace.ToDisplayString() == "System.Threading.Tasks";
    
    private static string NestedTypeFqn(INamedTypeSymbol symbol) =>
        symbol.ContainingType == null ? symbol.Name : $"{NestedTypeFqn(symbol.ContainingType)}.{symbol.Name}";
}
