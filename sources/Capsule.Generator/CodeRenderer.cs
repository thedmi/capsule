using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Capsule.Generator;

internal class CodeRenderer(
    SourceProductionContext context,
    CapsuleSpec spec,
    ImmutableArray<ExposeSpec> exposedMethods
)
{
    public void RenderCapsuleInterface()
    {
        if (spec.Interface is not CapsuleSpec.GeneratedInterface i)
        {
            return;
        }

        var namespaceName = spec.CapsuleClass.ContainingNamespace.ToDisplayString();

        var methods = exposedMethods.Select(d => RenderHullMethodOrProperty(d, false));

        var code = $$"""
            // <auto-generated/>
            #nullable enable

            namespace {{namespaceName}};

            public interface {{i.Name}}
            {
            {{string.Join("\n\n", methods)}}
            }
            """;

        context.AddSource($"{i.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    public void RenderExtensions()
    {
        var implClassName = spec.CapsuleClass.NestedTypeQualifiedName();
        var interfaceName = spec.Interface switch
        {
            CapsuleSpec.ResolvedInterface i => i.Symbol.NestedTypeQualifiedName(),
            CapsuleSpec.GeneratedInterface i => i.Name,
            CapsuleSpec.ProvidedInterface i => i.Name,
            _ => throw new ArgumentOutOfRangeException(),
        };

        var namespaceName = spec.CapsuleClass.ContainingNamespace.ToDisplayString();

        var extensionsClassName = implClassName.Replace(".", "") + "CapsuleExtensions";

        var methods = exposedMethods.Select(d => RenderHullMethodOrProperty(d, true));

        var code = $$"""
            // <auto-generated/>
            #nullable enable

            using Capsule;

            namespace {{namespaceName}};

            public static class {{extensionsClassName}}
            {
                public static {{interfaceName}} Encapsulate(this {{implClassName}} impl, CapsuleRuntimeContext context) =>
                    new Hull(impl, context.SynchronizerFactory.Create(impl, context.Host));

                public class Hull : {{interfaceName}} 
                {
                    private readonly {{implClassName}} _impl;
                    
                    private readonly ICapsuleSynchronizer _synchronizer;
                    
                    public Hull({{implClassName}} impl, ICapsuleSynchronizer synchronizer)
                    {
                        _impl = impl;
                        _synchronizer = synchronizer;
                    }
                    
                {{string.Join("\n\n    ", methods)}}
                }
            }
            """;

        // Add the source code to the compilation.
        context.AddSource($"{extensionsClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private string RenderHullMethodOrProperty(ExposeSpec exposeSpec, bool renderImplementation)
    {
        return exposeSpec.MemberSymbol switch
        {
            IMethodSymbol m => RenderHullMethod(
                m,
                exposeSpec.Synchronization,
                exposeSpec.PassThroughIfQueueClosed,
                exposeSpec.IsAsync,
                renderImplementation
            ),
            IPropertySymbol p => RenderHullProperty(p, exposeSpec.Synchronization, renderImplementation),
            IEventSymbol e => RenderHullEvent(e, renderImplementation),
            _ => throw new ArgumentOutOfRangeException(nameof(exposeSpec.MemberSymbol)),
        };
    }

    private string RenderHullMethod(
        IMethodSymbol method,
        Synchronization proxyMethod,
        bool passThroughIfQueueClosed,
        bool isAsync,
        bool renderImplementation
    )
    {
        var returnType =
            proxyMethod == Synchronization.EnqueueReturn && spec.Interface is CapsuleSpec.GeneratedInterface
                ? "void"
                : method.ReturnType.ToDisplayString();

        // The method can usually just pass the task back to the caller. However, with enqueue return and a
        // user-provided interface, we cannot guarantee that the types match, so we need an async operation to ensure
        // proper task encapsulation in all cases.
        var async = isAsync && proxyMethod == Synchronization.EnqueueReturn && renderImplementation ? "async " : "";

        var parameterDeclarations = string.Join(
            ", ",
            method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}")
        );

        var arguments = string.Join(", ", method.Parameters.Select(p => $"{p.Name}"));

        var signature = $"    public {async}{returnType} {method.Name}({parameterDeclarations})";

        var passThrough = passThroughIfQueueClosed ? ", true" : "";
        var asTask = IsValueTask(method.ReturnType) ? ".AsTask()" : "";

        var synchronizerCall =
            $"_synchronizer.{proxyMethod}(() => _impl.{method.Name}({arguments}){asTask}{passThrough})";

        var wrappedSynchronizerCall =
            proxyMethod != Synchronization.EnqueueReturn && IsValueTask(method.ReturnType)
                ? $"new {method.ReturnType}({synchronizerCall})"
                : synchronizerCall;

        var body = renderImplementation ? $" =>\n            {wrappedSynchronizerCall};" : ";";

        return $"{signature}{body}";
    }

    private static string RenderHullProperty(
        IPropertySymbol property,
        Synchronization synchronization,
        bool renderImplementation
    )
    {
        return $$"""
                    public {{property.GetMethod!.ReturnType}} {{property.Name}}
                """
            + (
                renderImplementation
                    ? $$"""
                         =>
                                    _synchronizer.{{synchronization}}(() => _impl.{{property.Name}});
                        """
                    : " { get; }"
            );
    }

    private static string RenderHullEvent(IEventSymbol evt, bool renderImplementation)
    {
        var type = evt.Type.ToDisplayString();
        var name = evt.Name;

        if (!renderImplementation)
        {
            return $"public event {type} {name};";
        }

        return $$"""
                public event {{type}} {{name}}
                    {
                        add => _impl.{{name}} += value;
                        remove => _impl.{{name}} -= value;
                    }
            """;
    }

    private static bool IsValueTask(ITypeSymbol typeSymbol) =>
        typeSymbol.Name == "ValueTask" && typeSymbol.ContainingNamespace.ToDisplayString() == "System.Threading.Tasks";
}
